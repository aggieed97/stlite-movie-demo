<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <title>Ed's Movies</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.76.0/build/style.css"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module">
      import { mount } from "https://cdn.jsdelivr.net/npm/@stlite/browser@0.76.0/build/stlite.js";
      mount(
      {
    requirements: ["plotly.express", "pandas", "requests"], // Packages to install
    entrypoint: "streamlit_app.py", // The target file of the `streamlit run` command
    files: {
      "streamlit_app.py": `
import streamlit as st
import pandas as pd
import plotly.express as px
import importlib
import requests
from io import StringIO
from typing import Literal

if importlib.util.find_spec("pyodide") is not None:
    from pyodide.http import open_url

@st.cache_data(show_spinner=False)
def read_url(url:str, **kwargs):
    """Read the CSV content from a URL"""

    # If pyodide is available
    if importlib.util.find_spec("pyodide") is not None:
        url_contents = open_url(url)
    else:
        r = requests.get(url)
        url_contents = StringIO(r.text)

    return pd.read_csv(
        url_contents,
        **kwargs
    )

st.set_page_config(page_title="Ed's Movies")

url = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQkpF4DO8orXrx94k9Hl9q8kF-lQbKXENLQL0xAoo_ap9OOUl0utwd7MeJn-0aGJBzQ--xdKVSvxe5z/pub?gid=505644229&single=true&output=csv"

df = read_url(url)
df[["Release_Date", "Date_Seen"]] = df[["Release_Date", "Date_Seen"]].apply(pd.to_datetime, errors="coerce", format="mixed")

year = list(df.Year.unique())
year.sort(reverse=True)

year_options = st.multiselect(
  "What year(s) would you like to visualize?",
  year,
  default=[year[0]]
)

year_option = year[0]

# Also, add a check to make sure at least one year is selected
if year_options:
    df_filtered = df[df.Year.isin(year_options)].copy()
    # It's good practice to sort by year and month for chronological plotting
    df_filtered.sort_values(by=['Year', 'Month'], inplace=True)
else:
    # If no years are selected, create an empty dataframe to avoid errors
    df_filtered = pd.DataFrame()

df = df[df.Year == year_option]

# Movie Calculations
time_spent_in_movies = df.Length.sum()
hours_spent = round(time_spent_in_movies/60, 2)
days_spent = round(hours_spent/24, 2)
movie_count_total = df.shape[0]
#st.write(movie_count_total)
duplicates = len(set((df[df.duplicated(subset=['Movie'])].Movie.to_list())))



st.title(f"Movies in {year_option}")
st.write(f"In {year_option}, I've seen {movie_count_total} movies spending {time_spent_in_movies} minutes. That is {hours_spent} hours or {days_spent} days in a theater!")
st.write(f"I've seen {duplicates} movies more than once!")

# Group the DataFrame by 'title' and count the occurrences
movie_counts = df.groupby('Movie').size().reset_index(name='Times Seen in a Theater')

# Filter the results where count is greater than 1
movie_count_df = movie_counts[movie_counts['Times Seen in a Theater'] > 1].sort_values(by="Times Seen in a Theater", ascending=False)

def static_table(
    df: pd.DataFrame,
    text_align: Literal["left", "center", "right"] = "center",
    line_color: str = "rgba(150, 150, 150, 0.3)",
) -> None:
    common_props = [
        ("text-align", text_align),
        ("border", f"1px solid {line_color}"),
        ("padding", "0.25rem 0.375rem"),
        ("vertical-align", "middle"),
        ("line-height", "1.5rem"),
    ]

    st.html(
        df.style.hide(axis="index")
        .format(precision=4)
        .set_table_styles(
            [
                {  # Header
                    "selector": "th",
                    "props": common_props,
                },
                {  # Data
                    "selector": "td",
                    "props": common_props,
                },
            ]
        )
        .to_html(table_attributes='style="width: 100%;"')
    )



# Display the styled DataFrame in Streamlit
if not movie_count_df.empty:
  static_table(movie_count_df, text_align="center")

option = st.selectbox(
  'Which tag would you like to add to the visualizations?',
  ['Twitter', 'Facebook/LinkedIn', 'Bluesky']
)

if option == 'Twitter':
  viz_tag = 'Graphic: @danger009mouse'
elif option == 'Facebook/LinkedIn':
  viz_tag = 'Graphic: Ed Salinas'
else:
  viz_tag = 'Graphic: dangermouse'

# Create a more descriptive title
title_text = f"Movie Count by Month in {', '.join(map(str, sorted(year_options)))}"

# Check if there is data to plot after filtering
if not df_filtered.empty:
    fig4 = px.histogram(
        data_frame=df_filtered,
        x="Month",
        color="Year",  # <-- This is the key change to create groups
        barmode='group', # <-- This ensures bars are side-by-side
        #text_auto=True,
        category_orders={"Month": ["January", "February", "March", "April", "May", "June",
                                   "July", "August", "September", "October", "November", "December"]},
        color_discrete_sequence=px.colors.sequential.RdBu
    # ).update_traces(
    #  textfont=dict(font=dict(color='white', size=14),
    #  textposition='outside'
    ).update_layout(
        title={
            'text': title_text,
            'y': 0.9,
            'x': 0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        yaxis_title="# of Movies",
        font=dict(
            size=20
        )
        # No need for showlegend=False, we want the legend now
    ).add_annotation(
        dict(font=dict(color='white', size=15),
             x=0.7,
             y=-0.25,
             showarrow=False,
             text=viz_tag,
             textangle=0,
             xanchor='left',
             xref="paper",
             yref="paper")
             )

    # Don't forget to display the chart!
    st.plotly_chart(fig4, use_container_width=True, key="monthly_count_chart")
else:
    st.warning("Please select at least one year to display the chart.")

if not df_filtered.empty:

    # 1. Data Preparation: Derive 'Day_of_Week' from the 'Date_Seen' column
    df_filtered['Day_of_Week'] = df_filtered['Date_Seen'].dt.day_name()

    # 2. Define Order: Create a list for correct chronological sorting on the chart
    day_order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

    # Create a title that includes the selected years
    dow_title_text = f"Movie Count by Day of the Week in {', '.join(map(str, sorted(year_options)))}"

    # 3. Build the Chart: Create the figure first
    fig_day_of_week = px.histogram(
        data_frame=df_filtered,
        x="Day_of_Week",
        color="Year",
        barmode="group",  # The stray ">" has been removed
        category_orders={"Day_of_Week": day_order},
        color_discrete_sequence=px.colors.sequential.RdBu
    )

    # 4. Update the layout and add annotations to the created figure
    fig_day_of_week.update_layout(
        title={
            'text': dow_title_text,
            'y': 0.9,
            'x': 0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        yaxis_title="# of Movies",
        xaxis_title="Day of the Week",
        font=dict(
            size=20
        ),
        showlegend=False
    ).add_annotation(  # Note: add_annotation can be chained to update_layout
        dict(font=dict(color='white', size=15),
             x=0.7,
             y=-0.2,
             showarrow=False,
             text=viz_tag,
             textangle=0,
             xanchor='left',
             xref="paper",
             yref="paper")
    )

    # Display the new chart in your Streamlit app with a unique key
    st.plotly_chart(fig_day_of_week, use_container_width=True, key="day_of_week_chart")

`,
    },
    streamlitConfig: {
      // Streamlit configuration
      "client.toolbarMode": "viewer",
    },
  },
  document.getElementById("root")
);
    </script>
  </body>
</html>